"""
# TODO: add docstring
"""
import os
import subprocess
import ffmpeg

CWD = os.getcwd()


def main(video_filepath, time_dicts):
    """
    video_filepath: a string path to mp4 video
    time_dicts: list of dicts containing:
        start: start time in seconds
        end: end time in seconds
        link: string to be embedded
        filepath: filepath to the ultrasound generated by the link
    """
    # video setup

    original_audio_duration = float(ffmpeg.probe(video_filepath)['streams'][0]['duration'])

    # rounded down to seconds
    original_audio_duration = original_audio_duration - original_audio_duration % 1

    # rounded down to 10s (ultrasound is 10s long)
    usable_audio_duration = original_audio_duration - original_audio_duration % 10

    # time checks on start/end
    check_time_list = []

    for time_dict in time_dicts:
        check_time_list.append(time_dict["start"])
        check_time_list.append(time_dict["end"])

    assert check_time_list[0] >= 0
    assert check_time_list[-1] <= usable_audio_duration

    for i in range(len(check_time_list) - 1):
        assert check_time_list[i] % 10 == 0

        if i % 2 == 0:
            assert check_time_list[i] < check_time_list[i + 1]
        else:
            assert check_time_list[i] <= check_time_list[i + 1]

    # # # start overlaying process
    output_filepath = overlay(time_dicts, video_filepath)

    if output_filepath is None:
        #TODO: add some kinda debeg logging system
        print('Audio Overlaying Failed')

    else:
    original_video = VideoFileClip(video_filepath)
        return output_filepath




def overlay(time_dicts, video_filepath):
    """
    time_dict: list of dict as described in main.
    video_filepath: string

    overlays the link ultrasound on the original video
    """
    # ffmpeg
    # -i {{path to vid}}
    # -itsoffset {{seconds}} -i {{path to wav1}}
    # -itsoffset {{seconds}} -i {{path to wav2}}
    # -filter_complex amix=inputs={{num streams}}:duration=longest
    # -c:v copy -c:a aac -b:a 320k -async 1 {{output filepath}}

    output_filepath = video_filepath.replace('uploaded_files', 'output_video')

    ffmpeg_builder = ['ffmpeg']

    # add input video args
    ffmpeg_builder.extend(['-i', video_filepath])

    # add input audio args
    for time_dict in time_dicts:
        start = time_dict["start"]
        end = time_dict["end"]
        filepath = time_dict["filepath"]
        time_cursor = start
        while time_cursor < end:
            # TODO: link audio is currently 2.5s long. aiming to change to 10s.
            # temp workaround: loop audio 3 times (7.5s)
            print('DEBUG cursor (s): {}'.format(time_cursor))
            ffmpeg_builder.extend(['-itsoffset', str(time_cursor), '-i', filepath])
            ffmpeg_builder.extend(['-itsoffset', str(time_cursor + 3), '-i', filepath])
            ffmpeg_builder.extend(['-itsoffset', str(time_cursor + 6), '-i', filepath])

            time_cursor += 10

    # add filter args
    ffmpeg_builder.extend([
        '-filter_complex',
        'amix=inputs={}:duration=longest'.format(str(len(time_dicts) + 1))
    ])

    # add output args
    ffmpeg_builder.extend([
        '-c:v',
        'copy',
        '-c:a',
        'aac',
        '-b:a',
        '320k',
        '-async',
        '1',
        output_filepath
    ])

    try:
        subprocess.run(ffmpeg_builder, check=True)
    except subprocess.CalledProcessError:
        return None

    return output_filepath
